---
title: "Introduction to R"
subtitle: '"How do you turn this thing on?"'
author: "Samuel Robinson, Ph.D."
date: "Sep. 4 2023"
output:
  beamer_presentation:
    incremental: true
    theme: "default"
    colortheme: "lily"
    highlight: "tango"
    fig_caption: false
classoption: aspectratio=169
df_print: kable
header-includes: 
  - \let\oldShaded\Shaded %Change fontsize of R code chunks
  - \let\endoldShaded\endShaded
  - \renewenvironment{Shaded}{\footnotesize\oldShaded}{\endoldShaded}
  - \let\oldverbatim\verbatim %Change fontsize of code chunk output
  - \let\endoldverbatim\endverbatim
  - \renewenvironment{verbatim}{\footnotesize\oldverbatim}{\endoldverbatim}
---

```{r setup, include=FALSE}
# #Trick to get smaller R code size with out resorting to LaTeX text sizes - this doesn't work if you use code chunks in incremental lists
# def.chunk.hook  <- knitr::knit_hooks$get("chunk")
# knitr::knit_hooks$set(chunk = function(x, options) {
#   x <- def.chunk.hook(x, options)
#   ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
# })
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message=TRUE, warning=TRUE, tidy=TRUE)
# knitr::opts_chunk$set(echo = TRUE)

```

## Motivation

- "Why do I need to learn R?"
  - Free, powerful, and very common
  - Interfaces with other languages (e.g. C++), and can help you learn other languages
- "What is R good at?"
  - Displaying data, running models, and processing data*
  - Writing presentations and papers
  - _Keeping a record of what you've done_
- "What is R bad at?"
  - No point-and-click interface; simple things can take more time
  - Can be slow if datasets are large*
- I am not here to teach you programming, but some basic techniques are useful

## RStudio GUI

::: columns

:::: {.column width="40%"}

- The __Console__ is the main input into R (where you tell it to do things)
- __Scripts__ are lists of commands that get passed into the console
- If you're using RStudio, 2 of the 4 panes will be dedicated to the console and scripts

::::

:::: {.column width="60%"}

![My (custom) RStudio setup](screenshot.png){width=100%}

::::

:::


## Objects and Functions

- Everything in R is either an __Object__ or a __Function__. All must have a unique name, or else the _Steve Problem_* occurs.
- Some common __objects__ (things stored in memory):
  - Strings, Logicals, & Numerics
  - Vectors & Matrices
  - Dataframes & Lists*
- Some common __functions__ (things done to objects):
  - _mean_, _sd_, _median_, _quantile_, _c_, _paste_
  - _plot_, _summary_ 
    - these are polymorphic functions: they do different things to different types of objects
  - Control flow - _if_ and _for_
    
## Objects

- Let's make some objects. These are all single objects:

   ```{r}
   myString <- "Hello world" #A string object
   myNumeric <- 12345 #A numeric object
   myLogical <- TRUE #A logical object
   ```
   
- These are objects joined into a _vector_, joined by the function c (concatenate):
   
   ```{r}
   myStringVec <- c("I like pie","I like cake","I like anything you bake")
   myNumericVec <- c(1,2,3,4,5)
   myLogicalVec <- c(TRUE,TRUE,FALSE,TRUE,FALSE,FALSE)
   ```
   
- How long are each of these vectors?

   ```{r}
   howLong <- c(length(myStringVec), length(myNumericVec), length(myLogicalVec))
   howLong #This executes the `print` command on `howLong`
   ```

## Vectors

- How do I get stuff out of the vectors I just made?

```{r}
myStringVec #Here's what's inside the whole thing
myStringVec[1] #Uses a single numeric
myStringVec[c(2,3)] #Uses a vector of numerics
myStringVec[c(TRUE,FALSE,TRUE)] #Uses a logical vector of same length
```

## Matrices

- Matrices are rectangular structures that hold values inside them:

   ```{r}
   (myMatrix <- matrix(1:9,ncol=3))
   ```

- Matrices are indexed by _rows_ and _columns_ (in that order):
   
   ```{r}
   myMatrix[1,3] #1st row, 3rd col
   myMatrix[,3] #All rows, 3rd column
   ```

## Dataframes

- Dataframes look similar to matrices, but can hold different data types in each column:

   ```{r}
   #Each column has a unique name, and must be the same length
   myDF <- data.frame(stringCol=myStringVec, numCol=myNumericVec[c(1:3)], 
                      logCol=myLogicalVec[c(1:3)])
   myDF
   ```
- 

  ```{r}
  summary(myDF) #This function summarizes each column
  ```

## Lists

::: columns

:::: column

>- Lists look similar to vectors, but can hold anything in each slot, including other lists. 

>- LOTS of things in R (e.g. model output) are specially-structured lists at their core

```{r tidy.opts=list(width.cutoff=25)}
myList <- list(stringSlot=myStringVec, numSlot=myNumericVec, 
                  logSlot=myLogicalVec, dfSlot = myDF)
```

::::

:::: column

```{r eval = TRUE, echo=FALSE}
myList
```

::::

:::
   

## Accessing Dataframes

- Dataframes can be accessed numerically, by their name slots, or with a mixture of the two:

```{r}
myDF[1,2]
myDF$numCol #This gets all of the column "numCol"
myDF[1,"numCol"]
```

## Accessing Lists 

- Similarly, lists can be accessed numerically (see below), or by their name slots:

```{r}
myList[[2]] #Needs 2 square brackets to isolate object
myList[['numSlot']]
myList$numSlot
myList[[4]][,3] #Same as myList$dfSlot$logCol
```

## Functions

- Functions take objects as __arguments__ (input) and return other __objects__ (output)

```{r eval=FALSE, include=TRUE}
myNumericVec
meanVec <- mean(myNumericVec) #Arithmetic mean (average)
sdVec <- sd(myNumericVec) #Standard deviation (sqrt(variance))
meanSdVec <- c(meanVec,sdVec) #Joins mean and SD into a vector
meanSdVec
?median #If you can't remember how a command works, use "?" to access the help files
```

## Homemade Functions

- You can make your own functions! This is useful if you have to do the same thing to many different input objects.

   ```{r}
   myFun <- function(input){ #Takes a vector of numbers
     A <- mean(input) #Take the mean of INPUT
     B <- sd(input) #Take the SD of INPUT
     C <- c(A,B) #Join A and B into a vector C
     return(C) #Return (output) C, then end the function
   }
   myFun(myNumericVec) #Same as previous slide
   ```

- 

   ```{r}
   myFun(myLogicalVec) #Logical vector is converted to 1 (TRUE) and 0 (FALSE)
   ```

- The objects inside of functions (A,B,C in the one above) disappear after the function runs. However, functions can see objects in the outer environment, so beware of the Steve Problem*

## Plotting

::: columns

:::: column

- The _plot_ command is useful for quickly looking at sets of data. The following CO2 dataset is built-in to R. To see others, type \texttt{data()}

```{r, co2plot, eval=FALSE, fig.height=5, fig.width=5, tidy=FALSE}
#Makes a plot of the uptake (y) and 
# concentration (x) columns of CO2 
# dataframe, and customizes axis labels
plot(x = CO2$conc, y = CO2$uptake, 
     xlab = 'Concentration (ppm)', 
     ylab = 'Uptake (g)', 
     main = 'Plot of CO2 Concentrations', 
     cex = 2)
```

:::: 

:::: column

```{r, co2plot, echo=FALSE, eval=TRUE}
```

::::

:::

## Plotting (cont.)

::: columns

:::: column

- The boxplot command can summarize _continuous_ and _categorical_ data

```{r, co2plot2, fig.height = 4, fig.width = 5, eval=FALSE, tidy.opts=list(width.cutoff=30)}
#Boxplot uses a formula rather than x,y vectors 
#Note: plot can also use formulas in lieu of x,y
boxplot(CO2$uptake ~ CO2$Type, xlab='Type', ylab='Uptake (g)') 
#Formula: uptake depends on (~) Type
```

:::: 

:::: column

```{r, co2plot2, echo = FALSE, eval = TRUE}
```

::::

:::

## Summary statistics

- Often we want to get the mean of one columns, but split it up by other things in the dataframe. Using the CO2 plant example, how does _uptake_ differ between _Type_?

::: columns

:::: column

```{r}
#Split up uptake by Type and Treatment, then take the mean
tapply(CO2$uptake,list(CO2$Type,CO2$Treatment),mean)
```

::::

:::: column

- It's annoying and repetitive to type "CO2" over and over again. You can use _with_ to avoid this (avoid using _attach_):

```{r}
#Runs command inside the name space of the CO2 object
with(CO2, tapply(uptake,list(Type,Treatment),sd))
```

::::

:::

## _if_ statements

- R can be told to do things only _if_ certain conditions apply. This is useful inside of functions for error handling:

```{r}
myFun2 <- function(x){
  xClass <- class(x) #What class is x? (Numeric, character, boolean)
  
  if(xClass=='character'){ #== means "are these things equal"?
    return('This is a string') #If x is a character, returns a message
  } else {
    return(mean(x)) #If x isn't a character, returns the mean of x
  }
}
myFun2(myStringVec)
myFun2(myNumericVec)

```

## for loops

- R can be told to do things _repeatedly_, using an index:

```{r}
classVec <- rep('',length(myList)) #Storage vector

#i will take on values 1 to 4, each time the loop repeats
for(i in 1:length(myList)){
  
  #ith slot of classVec becomes class from ith slot of myList
  classVec[i] <- class(myList[[i]]) 
}
classVec
```

## Reading csv files

- One very common practice is to read in your own data from a csv file. Excel files can be read in directly, but present other problems. 

```{r}
testDat <- read.csv('test_results.csv')
head(testDat) #head shows only first 6 rows of dataframe
```

- R can't handle spaces or other special characters in the column headers (replaces them with periods). It also tries to guess the proper data type for each column, but sometimes gets this wrong.

## A challenger approaches!

- Your supervisor has just given you a dataset (_test_results.csv_) recorded by two undergrads. However, these undergrads were in a hurry and have made some mistakes:
  
  - Read the _csv_ file and fix any mistakes. Bonus if you do this without using Excel!
  
  - Plot the concentration data by treatment group, then plot it for each undergrad. Does there look like much of a difference?
  
  - Some useful commands: __read.csv__, __boxplot__, __is.na__, __as.factor__

- Population growth models are common in ecology, and usually often take the form $n_t = n_{t-1} + rn_{t-1}$, where $n$ is the number of critters at some time point $t$, and $r$ is the change in $n$ from one point to the next (r = 0: no change). Using a \texttt{for} loop, write a simple population simulation using the following models:

  - Exponential growth: $n_t = n_{t-1}(1+r)$
  - Logistic growth: $n_t = n_{t-1}(1+ r(1-\frac{n_{t-1}}{k}))$
  - Predator-prey system: $\text{prey}_t = \text{prey}_{t-1}(1+ r_1 - a_1\text{predators}_{t-1});\text{ pred}_t = \text{pred}_{t-1}(1 + a_2\text{prey}_{t-1}-d)$
  
## Solutions (1)

```{r}
dat <- read.csv('test_results.csv',)
# print(dat)
dat <- dat[!is.na(dat$Concentration),] #Remove NA
dat$Treatment[dat$Treatment=='Bee'] <- 'B' #Change Bee to B
dat$Lab.Member[dat$Lab.Member=='Same'] <- 'Sam' #Change Same to Sam
dat$Treatment <- as.factor(dat$Treatment) #Change characters to factor
dat$Lab.Member <- as.factor(dat$Lab.Member) 
dat$Concentration[dat$Concentration==30] <- 3.0

boxplot(Concentration ~ Treatment,data=dat)

```
  
  