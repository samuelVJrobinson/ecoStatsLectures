---
title: "Introduction to R"
subtitle: '"How do you turn this thing on?"'
author: "Samuel Robinson, Ph.D."
date: "Sep. 4 2023"
output:
  beamer_presentation:
    incremental: true
    theme: "default"
    colortheme: "lily"
    highlight: "tango"
    fig_caption: false
classoption: aspectratio=169
df_print: kable
header-includes: 
  - \let\oldShaded\Shaded %Change fontsize of R code chunks
  - \let\endoldShaded\endShaded
  - \renewenvironment{Shaded}{\footnotesize\oldShaded}{\endoldShaded}
  - \let\oldverbatim\verbatim %Change fontsize of code chunk output
  - \let\endoldverbatim\endverbatim
  - \renewenvironment{verbatim}{\footnotesize\oldverbatim}{\endoldverbatim}
---

```{r setup, include=FALSE}
# #Trick to get smaller R code size with out resorting to LaTeX text sizes - this doesn't work if you use code chunks in incremental lists
# def.chunk.hook  <- knitr::knit_hooks$get("chunk")
# knitr::knit_hooks$set(chunk = function(x, options) {
#   x <- def.chunk.hook(x, options)
#   ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
# })
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message=TRUE, warning=TRUE, tidy=TRUE)
# knitr::opts_chunk$set(echo = TRUE)

```

## Motivation

- "Why do I need to learn R?"
  - Free, powerful, and very common
  - Interfaces with other languages (e.g. C++), and can help you learn other languages
- "What is R good at?"
  - Displaying data, running models, and processing data
  - Writing presentations and papers
  - _Keeping a record of what you've done_
- "What is R bad at?"
  - No point-and-click interface; simple things can take more time
  - Can be slow if datasets are large
- This is not a course in R programming (see [here](https://r4ds.hadley.nz/), [here](https://adv-r.hadley.nz/index.html), [here](https://r-pkgs.org/) , but you do need some basic techniques

## RStudio GUI

::: columns

:::: {.column width="40%"}

- The __Console__ is the main input into R (where you tell it to do things)
- __Scripts__ are lists of commands that get passed into the console
- If you're using RStudio, 2 of the 4 panes will be dedicated to the console and scripts

::::

:::: {.column width="60%"}

![My (custom) RStudio setup](screenshot.png){width=100%}

::::

:::


## Objects and Functions

- Everything in R is either an __Object__ or a __Function__. All must have a unique name, or else the _Steve Problem_\footnote{Two guys named Steve at a party: which one is which?} occurs.
- Some common __objects__ (things stored in memory):
  - Characters, Logicals, & Numerics
  - Vectors & Matrices
  - Dataframes & Lists
- Some common __functions__ (things done to objects):
  - _mean_, _sd_, _median_, _quantile_, _c_, _paste_
  - _plot_, _summary_ 
    - these are polymorphic functions: they do different things to different types of objects
  - Control flow - _if_ and _for_
    
## Objects

- Let's make some objects. These are all single objects:

   ```{r}
   myString <- "Hello world" #A string object
   myNumeric <- 12345 #A numeric object
   myLogical <- TRUE #A logical object
   ```
   
- These are objects joined into a _vector_, joined by the function c (concatenate):
   
   ```{r}
   myCharVec <- c("I like pie","I like cake","I like anything you bake")
   myNumVec <- c(1,2,3,4,5)
   myLogVec <- c(TRUE,TRUE,FALSE,TRUE,FALSE,FALSE)
   ```
   
- How long are each of these vectors?

   ```{r}
   howLong <- c(length(myCharVec), length(myNumVec), length(myLogVec))
   howLong #This executes the `print` command on `howLong`
   ```

## Vectors - ``getting"
```{r}
myCharVec #Here's what's inside the whole thing
```

\pause 

- Single number:
  
  ```{r}
  myCharVec[1]
  ```

- Vector of numbers
  
  ```{r}
  myCharVec[c(2,3)] 
  ```
- Logical vector
 
  ```{r}
  myCharVec[c(TRUE,FALSE,TRUE)] 
  ```
  
## Vectors - ``setting"

Vectors are set in the same way, using the assignment operator: <- OR =
  
\pause  
  
- String vector
  ```{r}
  myCharVec[c(2,3)] <- c('Cats','Dogs')
  ```
- Logical vector
  ```{r}
  myCharVec[c(TRUE,FALSE,FALSE)] = 'Parakeets'
  ```
- Results:
  ```{r}
  myCharVec #Here's what's inside the whole thing
  ```

## Class conversions
  
Vectors (or other data) can be converted between __classes__, usually using _as.something_ statements:

\pause

- Logical to numeric
  ```{r}
  as.numeric(myLogVec)
  ```
  
- Numeric to character
  ```{r}
  as.character(myNumVec)
  ```

- Characters to __factors__: these represent _categories_ or experimental levels
  ```{r}
  as.factor(myCharVec) #Default order is alphabetical
  ```
  
<!-- ## Matrices -->

<!-- - Matrices are rectangular structures that hold values inside them: -->

<!--    ```{r} -->
<!--    (myMatrix <- matrix(1:9,ncol=3)) -->
<!--    ``` -->

<!-- - Matrices are indexed by _rows_ and _columns_ (in that order): -->

<!--    ```{r} -->
<!--    myMatrix[1,3] #1st row, 3rd col -->
<!--    myMatrix[,c(FALSE,FALSE,TRUE)] #All rows, 3rd column -->
<!--    ``` -->

## Dataframes

- Dataframes look similar to matrices, but can hold different data types in each column:

  ```{r tidy.opts=list(width.cutoff=30)}
  myDF <- data.frame(stringCol=myCharVec, numCol=myNumVec[c(1:3)], 
    logCol=myLogVec[c(1:3)])
  myDF
  ```
- 
  ```{r}
  summary(myDF) #This function summarizes each column
  ```

## Accessing Dataframes

Dataframes can be accessed numerically, by their name slots (using the $ operator), or with a mixture of the two:

\pause

-
  ```{r}
  myDF[1,2]
  ```
  
-
  ```{r}
  myDF$numCol #This gets all of the column "numCol"
  ```

-
  ```{r}
  myDF[1,"numCol"]
  ```
  
-
  ```{r}
  myDF$numCol[1]
  ```
  
## Manipulating dataframe

Like other objects, you can alter dataframes 

- You can add columns
  ```{r, eval=FALSE}
  myDF$numCol2 <- myDF$numCol*3 #Multiplies numCol by 3
  ```

- You can also alter columns in place, or elements within columns
  ```{r eval=FALSE}
  myDF$numCol <- (myDF$numCol)^2 #Square of numCol
  myDF$numCol[3] <- myDF$numCol[3] - myDF$numCol[2] #Subtracts 2nd from 3rd
  ```  
- You can delete columns by subsetting the dataframe, or assigning the column to \texttt{NULL}
  ```{r eval=FALSE}
  myDF <- myDF[,c(1,2)] #Selects only column 1 and 2
  myDF$numCol <- NULL #Removes numCol
  ```
  
- We'll learn easier ways of doing this next week using the \texttt{tidyverse}
  
  
## Reading csv files

- One common practice is to read in your own dataframe from a csv file \footnote{Excel files can be read in, but can cause problems} 

  ```{r}
  testDat <- read.csv('test_results.csv') #Path to csv file
  head(testDat) #head shows only the first 6 rows of dataframe
  ```
- R can't handle spaces or other special characters in the column headers (replaces them with periods). It also tries to guess the proper data type for each column
- Make sure that the csv file is in your _working directory_

## Plotting

::: columns

:::: column

- The _plot_ command is useful for quickly looking at sets of data. The following CO2 dataset is built-in to R.\footnotemark 

```{r, co2plot, eval=FALSE, fig.height=5, fig.width=5, tidy=FALSE}
#Makes a plot of the uptake (y) and 
# concentration (x) columns of CO2 
# dataframe, and customizes axis labels
plot(x = CO2$conc, y = CO2$uptake, 
     xlab = 'Concentration (ppm)', 
     ylab = 'Uptake (g)', 
     main = 'Plot of CO2 Concentrations', 
     cex.lab = 2, cex.main=2)
```

:::: 

:::: column

```{r, echo=FALSE, eval=TRUE, fig.height=5, fig.width=5}
par(mar=c(5,5,4,2)+0.1)
plot(x = CO2$conc, y = CO2$uptake, 
     xlab = 'Concentration (ppm)', 
     ylab = 'Uptake (g)', 
     main = 'Plot of CO2 Concentrations', 
     cex.lab = 2, cex.main=2)
```

::::

:::

\footnotetext{To see others, type \texttt{data()} in the console}

## More Plotting 

::: columns

:::: column

- The boxplot command can summarize _continuous_ and _categorical_ data

```{r, co2plot2, eval=FALSE, tidy.opts=list(width.cutoff=40)}
#Boxplot uses a formula rather than x,y vectors 

#Formula: uptake depends on (~) Type
boxplot(CO2$uptake ~ CO2$Type, 
        xlab='Type',
        ylab='Uptake (g)',
        cex.lab = 2, cex.main=2)

```

:::: 

:::: column

```{r, echo = FALSE, eval = TRUE, fig.height = 5, fig.width = 5}
par(mar=c(5,5,4,2)+0.1)
boxplot(CO2$uptake ~ CO2$Type, 
        xlab='Type',
        ylab='Uptake (g)',
        cex.lab = 2)
```

::::

:::


## First challenge

Your supervisor has just given you a dataset (_test_results.csv_) recorded by two undergrads. However, these undergrads were in a hurry and have made some mistakes:
  
  >- Make a __script__ in R, and use this to record what you do
  
  >- Read the _csv_ file and fix any mistakes. Bonus if you do this without using Excel!
  
  >- Plot the concentration data by treatment group, then plot it for each undergrad. Does there look like much of a difference?
  
  >- Some useful commands: __read.csv__, __boxplot__, __is.na__, __as.factor__, __summary__

## Functions

- Functions take objects as __arguments__ (input) and return other __objects__ (output)
  ```{r}
  myNumVec <- c(1,2,3,4,5)
  meanVec <- mean(myNumVec) #Arithmetic mean (average)
  sdVec <- sd(myNumVec) #Standard deviation (sqrt(variance))
  meanSdVec <- c(meanVec,sdVec) #Joins mean and SD into a vector
  meanSdVec
  ```
  
- If you can't remember how a command works, use ? in the console to access the help files (e.g. \texttt{?median})
  

## Homemade Functions

- You can make your own functions! This is useful if you have to do the same thing to many different input objects.

   ```{r}
   myFun <- function(input){ #Takes a vector of numbers
     A <- mean(input) #Take the mean of INPUT
     B <- sd(input) #Take the SD of INPUT
     C <- c(A,B) #Join A and B into a vector C
     return(C) #Return (output) C, then end the function
   }
   myFun(myNumVec) #Same as previous slide
   ```
   
<!-- - If you pass in a logical vector, it will convert it to numeric (0 and 1) -->
<!--   ```{r} -->
<!--   myLogVec <- c(TRUE,TRUE,FALSE,TRUE) -->
<!--   myFun(myLogVec)  -->
<!--   ``` -->

- The objects inside of functions (A, B, C in the one above) disappear after the function runs. However, _functions can see objects in the outer environment_, so beware of the Steve Problem*


## Summary statistics

Often we want to get the mean of one columns, but split it up by other things in the dataframe. 

\pause

- Using the CO2 plant example, how does _uptake_ differ between _Type_?

  ```{r}
  #Split up uptake by Type and Treatment, then take the mean
  tapply(CO2$uptake, list(CO2$Type, CO2$Treatment), mean)
  ```

- Typing "CO2" over and over again is annoying. You can use _with_ to avoid repeating the name of the dataframe (avoid using _attach_)

  ```{r, eval=FALSE}
  #Runs command inside the name space of the CO2 object
  with(CO2,tapply(uptake, list(Type, Treatment), sd))
  ```

## _if_ statements

- R can be told to do things only _if_ certain conditions apply. This is useful inside of functions for error handling:

```{r}
myFun2 <- function(x){
  xClass <- class(x) #What class is x? (Numeric, character, boolean)
  
  if(xClass=='character'){ #== means "are these things equal"?
    return('This is a string') #If x is a character, returns a message
  } else {
    return(mean(x)) #If x isn't a character, returns the mean of x
  }
}
myFun2(myCharVec)
myFun2(myNumVec)

```

## __for__ loops

- R can be told to do things repeatedly, using an _index_ inside a loop:
  ```{r}
  classVec <- rep(0,10) #Storage vector of zeros, 10 long
  classVec[c(1,2)] <- 1 #Set first two slots to 1
  
  #Each time the loop repeats, i will take on values 3 to 10
  for(i in 3:length(classVec)){
    #ith slot of classVec becomes the sum of the previous two slots
    classVec[i] <- classVec[i-1] + classVec[i-2]
  }
  ```
-
  ```{r}
  classVec #First 10 numbers in the Fibbonaci sequence
  ```

## Second challenge

Population growth models are common in ecology, and usually often take the form $n_t = n_{t-1} + rn_{t-1}$, where $n$ is the number of critters at some time point $t$, and $r$ is the change in $n$ from one point to the next (r = 0: no change). 

- Write a \texttt{function} (with a \texttt{for} loop inside) that performs a simple population simulation using the following models:
  - Exponential growth: $n_t = n_{t-1}(1+r)$
  - Logistic growth: $n_t = n_{t-1}(1+ r(1-\frac{n_{t-1}}{k}))$
  <!-- >- Predator-prey cycles (Lotka-Volterra):  -->
  <!--   >- $\text{prey}_t = \text{prey}_{t-1}(1+ r_1 - a_1\text{pred}_{t-1})$ -->
  <!--   >- $\text{pred}_t = \text{pred}_{t-1}(1 + a_2\text{prey}_{t-1}-d)$ -->
- Make a simple plot of your results
  
Hint: functions need input variables that tell them what to do. The input variables here could be things like _starting population_ ($n_0$), _growth rate_ ($r$), and _number of time steps_ ($T$) to simulate
    
  
## Lists

::: columns

:::: column

>- Lists look similar to vectors, but can hold anything in each slot, including other lists.

>- LOTS of things in R (e.g. model output) are specially-structured lists at their core

```{r tidy.opts=list(width.cutoff=25)}
myList <- list(charSlot=myCharVec,
               numSlot=myNumVec,
               logSlot=myLogVec,
               dfSlot = myDF)
```

::::

:::: column

```{r eval = TRUE, echo=FALSE}
myList
```

::::

:::

## Accessing Lists

Lists can be accessed numerically or logically, or by their name slots:

```{r}
myList[[2]] #Needs 2 square brackets to isolate object
myList[['numSlot']]
myList$numSlot
myList[[4]][,3] #Same as myList$dfSlot$logCol
```


## _lapply_ and _sapply_

Loops can be slow: using a __functional__ is generally better (if each step doesn't depend on the previous one)

\pause

```{r}
input <- c(1,2,3) #Input vector
pFun <- function(N,type='normal'){
  if(type=='poisson') rpois(N,3) else rnorm(N,3)
}
lapply(input,pFun,type='poisson') #Generates a list of N Poisson random numbers
```

\pause

Different output formats: _lapply_ uses a list, _sapply_ uses a vector (or matrix)

## Third challenge

The discrete logistic growth equation has some interesting mathematical properties (see [here](https://en.wikipedia.org/wiki/Logistic_map) and [here](https://www.nature.com/articles/261459a0)). At certain values of $r$ the population converges to the carrying capacity $K$, while at other values it cycles between multiple values.

::: columns

:::: column

Using _lapply_, _sapply_ and the logistic function you wrote for the second challenge:

>- Write a script that iterates across a range of $r$ values: $1\leq r \leq 3$
>- At each $r$ value, how many unique values exist?
>- Keep $K$ at 100 and $n_0$ at 1 for now. Use a simulation time of $t=1000$, but discard the first 100 points

:::: 

:::: column

```{r, echo=FALSE, eval=TRUE, fig.width=5, fig.height=4.5}
logFun <- function(r,k,t,n0){ #Create logistic growth function
  m <- rep(NA,t) #Empty vector
  m[1] <- n0 #Fill in the first number
  for(i in 2:t){
    m[i] <- m[i-1] + m[i-1]*r*(1-(m[i-1]/k))
  }
  return(m)
}

{ 
  par(mfrow=c(2,2))
    for(r in c(0.5,2,2.5,2.9)){
      l <- logFun(r,100,1000,1)
      l <- round(l)
      plot(l[1:100],type='n',xlab='Time',ylab='Population',
           main=paste0('r = ',r,', ', length(unique(l[900:1000])),' states'))
      abline(h=100,col='red')
      lines(l[1:100])
    }
  par(mfrow=c(1,1))  
}
```


::::

:::

## Complex behaviour from a simple system

```{r bifurcation, echo=FALSE, eval=TRUE, fig.width=12, dpi=200}
rSeq <- seq(1,3,0.01) #Sequence of r values to use

logSim <- lapply(rSeq,function(r){
  l <- logFun(r,100,3000,1)[2001:3000] #Takes only samples after t = 2000 ("burn-in" period)
  l <- round(l,1) #Rounds to 1 digit - keeps things simple for now
  unique(l)
})

#Plots of simulation
{
  par(mfrow=c(2,1))
  
  X <- rSeq
  Y <- sapply(logSim,length)
  plot(X,log(Y),type='b',ylab='log(Number of states)',xlab='',pch=19)
  
  X <- rep(rSeq,sapply(logSim,length))
  Y <- unlist(logSim) 
  plot(X,Y,pch=19,ylab='Stable states',xlab='r value',cex=0.25)
  par(mfrow=c(1,1))
}

```

## To do this week: 

Get a dataset to work with! This can be:

1. Your own dataset that you want to analyze
2. Another dataset that you think might look like your future one
  - Can be from another student (ask your supervisor if they have any ``leftovers" from previous students)
  - Take a look at a data repository like [Dryad](https://datadryad.org/search)

Try loading this data into R and play around with it: make some simple plots, or get some summary statistics. Bring it next week and we'll continue using it.
